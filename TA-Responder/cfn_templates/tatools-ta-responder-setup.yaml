AWSTemplateFormatVersion: '2010-09-09'
Description: Trusted Advisor Responder (workflow components) - This templates deploys EventBridge rules, Lambda functions, DynamoDB tables and IAM roles for the TA Responder automation workflow.

Parameters:
  GenAIRecommendationsEnabled:
    Type: String
    AllowedValues: 
      - 'true'
      - 'false'
    Default: 'true'
    Description: (Optional) Enable Gen AI recommendations for Trusted Advisor findings
  GenAIModelId:
    Type: String
    Default: 'anthropic.claude-3-5-sonnet-20240620-v1:0'
    Description: (Optional) The Bedrock Model ID to be used for Gen AI recommendations. Only if "GenAIRecommendationsEnabled" is set to 'true', otherwise ignored.

Conditions:
  CreateGenAIResources: !Equals 
    - !Ref GenAIRecommendationsEnabled
    - 'true'

Resources:

  # DDB Table with the most up to date state of Trusted Advisor Checks sourced from Security Hub or AWS Config
  TrustedAdvisorCheckTrackerTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: hashKey
          AttributeType: S
        - AttributeName: resource
          AttributeType: S
      KeySchema:
        - AttributeName: hashKey
          KeyType: HASH
        - AttributeName: resource
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST
      TableName: TrustedAdvisorCheckTrackerTable
      StreamSpecification:
        StreamViewType: NEW_IMAGE

  # Lambda function that ingest Trusted Advisor Checks results and update its state in the DDB TrustedAdvisorCheckTrackerTable
  TrustedAdvisorCheckTrackerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: TrustedAdvisorCheckTrackerFunction
      Runtime: python3.12
      Timeout: 300
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          """TrustedAdvisorCheckTrackerFunction - Logic for tracking the most recent status of TA checks in a DDB table"""

          import hashlib
          import logging
          import time

          import boto3
          import dateutil.parser

          logging.getLogger().setLevel(logging.INFO)
          logger = logging.getLogger()

          DDB_TABLE_NAME = "TrustedAdvisorCheckTrackerTable"


          def convert_to_epoch(datetime_str):
              return int(time.mktime(dateutil.parser.parse(datetime_str).timetuple()))


          def lambda_handler(event, context):
              # Parse the Trusted Advisor event data
              detail = event.get("detail", {})
              check_name = detail.get("check-name")
              check_item_detail = detail.get("check-item-detail", {})
              status = check_item_detail.get("Status")
              last_updated_time_str = check_item_detail.get("Last Updated Time")
              last_updated_time_epoch = convert_to_epoch(last_updated_time_str)
              resource = check_item_detail.get("Resource")
              region = check_item_detail.get("Region")

              # Create a hash key from check_name, resource and region
              hash_key = hashlib.sha256(
                  (check_name + resource + region).encode("utf-8")
              ).hexdigest()

              dynamodb = boto3.resource("dynamodb")
              table = dynamodb.Table(DDB_TABLE_NAME)

              # Check if the item already exists in the table
              existing_item = table.get_item(Key={"hashKey": hash_key, "resource": resource}).get(
                  "Item"
              )

              if existing_item:
                  existing_time_epoch = existing_item.get("lastUpdatedTimeEpoch")

                  # Update the existing item with new values. Only if the check update is more recent than
                  # what is recorded in the DDB TrustedAdvisorCheckTrackerTable
                  if last_updated_time_epoch > existing_time_epoch:
                      table.put_item(
                          Item={
                              "hashKey": hash_key,
                              "checkName": check_name,
                              "resourceStatus": status,
                              "lastUpdatedTime": last_updated_time_str,
                              "lastUpdatedTimeEpoch": last_updated_time_epoch,
                              "resource": resource,
                              "region": region,
                          }
                      )
                  else:
                      logger.info(
                          f"Skipping update for {hash_key}/{check_name} as the existing time is more recent."
                      )
              else:
                  # Create a new item in the table
                  table.put_item(
                      Item={
                          "hashKey": hash_key,
                          "checkName": check_name,
                          "resourceStatus": status,
                          "lastUpdatedTime": last_updated_time_str,
                          "lastUpdatedTimeEpoch": last_updated_time_epoch,
                          "resource": resource,
                          "region": region,
                      }
                  )

              return
      Role: !GetAtt TrustedAdvisorCheckTrackerLambdaExecutionRole.Arn

  TrustedAdvisorCheckTrackerLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:PutItem'
                Resource: !GetAtt TrustedAdvisorCheckTrackerTable.Arn

  TrustedAdvisorCheckTrackerResourceBasedPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TrustedAdvisorCheckTrackerFunction
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      SourceArn:
        Fn::GetAtt: 
          - "TrustedAdvisorCheckUpdatesRule"
          - "Arn"

  # EventBridge Rule forwarding events related to Trusted Advisor Checks results sourced from Security Hub or AWS Config
  # Events are forwarded to the TrustedAdvisorCheckTrackerFunction and to the TrustedAdvisorCheckUpdatesRuleLogGroup
  TrustedAdvisorCheckUpdatesRule:
    Type: AWS::Events::Rule
    Properties:
      Name: TrustedAdvisorCheckUpdatesRule
      EventPattern:
        source:
          - 'aws.trustedadvisor'
        detail-type:
          - 'Trusted Advisor Check Item Refresh Notification'
        detail:
          check-name:
            - exists: true
          check-item-detail:
            Status:
            - exists: true
            "Last Updated Time":
            - exists: true
            Resource:
            - exists: true
            Region:
            - exists: true
      State: ENABLED
      Targets:
        - Arn: !GetAtt TrustedAdvisorCheckTrackerFunction.Arn
          Id: TACheckTrackerFunctionTarget
        - Arn: !GetAtt TrustedAdvisorCheckUpdatesRuleLogGroup.Arn
          Id: CloudWatchLogGroupTarget

  # CloudWatch Log Group as another target of the EventBridge TrustedAdvisorCheckUpdatesRule
  TrustedAdvisorCheckUpdatesRuleLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/events/TrustedAdvisorCheckUpdatesRule
      RetentionInDays: 30
  
  # CloudWatch Log Group resource-based policy allowing EventBridge to forward events to the TrustedAdvisorCheckUpdatesRuleLogGroup
  LogGroupForEventsPolicy:
    Type: AWS::Logs::ResourcePolicy
    Properties:
      PolicyName: EventBridgeToCWLogsPolicy
      PolicyDocument: !Sub >
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Sid": "EventBridgetoCWLogsCreateLogStreamPolicy",
              "Effect": "Allow",
              "Principal": {
                "Service": [
                  "events.amazonaws.com"
                ]
              },
              "Action": [
                "logs:CreateLogStream"
              ],
              "Resource": [
                "${TrustedAdvisorCheckUpdatesRuleLogGroup.Arn}"
              ]
            },
            {
              "Sid": "EventBridgetoCWLogsPutLogEventsPolicy",
              "Effect": "Allow",
              "Principal": {
                "Service": [
                  "events.amazonaws.com"
                ]
              },
              "Action": [
                "logs:PutLogEvents"
              ],
              "Resource": [
                "${TrustedAdvisorCheckUpdatesRuleLogGroup.Arn}"
              ],
              "Condition": {
                "ArnEquals": {"AWS:SourceArn": "${TrustedAdvisorCheckUpdatesRule.Arn}"}
              }
            }
          ]
        }

  # From here starts resources related to the automation workflow

  # DDB table with the mapping configuration to use between a Trusted Advisor Check and a SSM Automation Document.
  AutomationMappingTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: checkName
          AttributeType: S
      KeySchema:
        - AttributeName: checkName
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      TableName: AutomationMappingTable

  # DDB table for tracking the execution of SSM Automation Documents and any corresponding OpsItem.
  AutomationExecutionTrackerTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: automationExecutionId
          AttributeType: S
      KeySchema:
        - AttributeName: automationExecutionId
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      TableName: AutomationExecutionTrackerTable

  # Lambda function ingesting events from the DDB TrustedAdvisorCheckTrackerTable event stream.
  # This function has the logic for creating OpsItems and executing SSM Automation Documents (if mapping configuration is in place)
  TrustedAdvisorResultHandlerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: TrustedAdvisorResultHandlerFunction
      Handler: index.lambda_handler
      Runtime: python3.12
      Timeout: 300
      Role: !GetAtt TrustedAdvisorResultHandlerExecutionRole.Arn
      Environment:
        Variables:
          GEN_AI_RECOMMENDATIONS_ENABLED: !Ref GenAIRecommendationsEnabled
          AUTOMATION_DOCUMENT_INVOKE_MODEL_ROLE: !If 
            - CreateGenAIResources
            - !GetAtt TaResponderAutomationExecutionRoleInvokeModel.Arn
            - 'NOT_ENABLED'
      Code:
        ZipFile: !Sub |
          """TrustedAdvisorResultHandler - Lambda function ingesting events from the DDB TrustedAdvisorCheckTrackerTable event stream. This function has the logic for creating OpsItems and executing SSM Automation Documents (if mapping configuration is in place)"""

          import json
          import logging
          import os
          import re

          import boto3
          from botocore.exceptions import ClientError

          logging.getLogger().setLevel(logging.INFO)
          logger = logging.getLogger()

          AUTOMATION_MAPPING_DDB_TABLE_NAME = "AutomationMappingTable"
          AUTOMATION_EXECUTION_TRACKER_DDB_TABLE_NAME = "AutomationExecutionTrackerTable"
          AUTOMATION_DOCUMENT_INVOKE_MODEL = "taResponderAutomationDocumentInvokeModel"
          AUTOMATION_DOCUMENT_INVOKE_MODEL_ROLE = os.environ[
              "AUTOMATION_DOCUMENT_INVOKE_MODEL_ROLE"
          ]
          GEN_AI_RECOMMENDATIONS_ENABLED = os.environ["GEN_AI_RECOMMENDATIONS_ENABLED"].lower() == "true"


          def _replace_resource_id(automation_parameters, resource_id):
              """
              Replace any instance of '$resourceId' in the 'automation_parameters' object with the value of 'resource_id'

              :param automation_parameters: The automation parameters object with instances of the '$resourceId' variable
              :param resource_id: The resource ID to include in the automation parameters object
              :return: The modified automation parameters object
              """
              if isinstance(automation_parameters, dict):
                  for key, value in automation_parameters.items():
                      if isinstance(value, str):
                          automation_parameters[key] = value.replace("$resourceId", resource_id)
                      elif isinstance(value, (dict, list)):
                          automation_parameters[key] = _replace_resource_id(value, resource_id)
              elif isinstance(automation_parameters, list):
                  for i, item in enumerate(automation_parameters):
                      if isinstance(item, str):
                          automation_parameters[i] = item.replace("$resourceId", resource_id)
                      elif isinstance(item, (dict, list)):
                          automation_parameters[i] = _replace_resource_id(item, resource_id)
              return automation_parameters


          def _create_ops_item(check_name, resource_arn, operational_data):
              """
              Create an OpsItem in SSM with the provided check name, resource ARN, and operational data.

              :param check_name: Name of the Trusted Advisor check
              :param resource_arn: ARN of the resource
              :param operational_data: Operational data for the OpsItem
              :return: OpsItem ID if successful, None otherwise
              """
              try:
                  ssm_ops_item_client = boto3.client("ssm")
                  ops_item = ssm_ops_item_client.create_ops_item(
                      Description=f"{check_name}: {resource_arn}",
                      OperationalData=operational_data,
                      Source="Trusted Advisor",
                      Title=f"[TA] [{check_name}] [{resource_arn}]",
                  )
                  ops_item_id = ops_item["OpsItemId"]
                  logger.info(f"OpsItem {ops_item_id} created for resource {resource_arn}")

              except Exception as e:
                  # Check if the error is OpsItemAlreadyExistsException
                  if e.response["Error"]["Code"] == "OpsItemAlreadyExistsException":
                      ops_item_id = e.response["OpsItemId"]
                      logger.info(f"OpsItem {ops_item_id} already exists for {resource_arn}")
                  else:
                      logger.error(f"Error creating OpsItem for resource {resource_arn}: {e}")
                      return None

              return ops_item_id


          def _put_item_in_automation_execution_ddb(automation_execution_id, ops_item_id, region):
              """
              Create item in AutomationExecutionTrackerTable DDB table with the OpsItem Id and SSM Automation Document execution Id.
              This allows SSMAutomationExecutionEventsHandler Lambda function to track the execution of the SSM Automation Document and update the corresponding OpsItem.

              :param automation_execution_id: SSM Automation Document execution Id
              :param ops_item_id: OpsItem Id
              :param region: AWS region
              :return: None
              """
              try:
                  dynamodb = boto3.resource("dynamodb")
                  automation_execution_table = dynamodb.Table(
                      AUTOMATION_EXECUTION_TRACKER_DDB_TABLE_NAME
                  )
                  automation_execution_table.put_item(
                      Item={
                          "automationExecutionId": automation_execution_id,
                          "opsItemId": ops_item_id,
                          "region": region,
                      }
                  )

              except ClientError as e:
                  logger.error(
                      f"Error adding item to DDB AutomationExecutionTrackerTable for execution {automation_execution_id} and OpsItem {ops_item_id}: {e}"
                  )


          def _start_automation_execution(document_name, automation_parameters, region):
              """
              Start an SSM automation execution based on the provided document name and parameters.

              :param document_name: Name of the SSM automation document
              :param automation_parameters: Parameters for the SSM automation execution
              :param region: AWS region
              :return: Automation execution ID, or None if an error occurred
              """
              try:
                  ssm_document_execution_client = boto3.client("ssm", region_name=region)
                  automation_execution = ssm_document_execution_client.start_automation_execution(
                      DocumentName=document_name, Parameters=automation_parameters
                  )

                  automation_execution_id = automation_execution["AutomationExecutionId"]

                  logger.info(f"Automation execution started: {automation_execution_id}")

              except ClientError as e:
                  logger.error(f"Error starting the automation execution: {e}")
                  return None

              return automation_execution_id


          def _get_ddb_mapping_item(check_name):
              """
              Retrieve the mapping item from the AutomationMappingTable DDB table based on the check name.
              Example of mapping item:
              {
                  "checkName": {
                      "S": "Security groups should not allow unrestricted access to ports with high risk"
                  },
                  "ssmAutomationDocument": {
                      "S": "AWS-DisablePublicAccessForSecurityGroup"
                  },
                  "regexPattern": {
                      "S": "(sg-\\w+)"
                  },
                  "automationParameters": {
                      "S": "{\"GroupId\": [\"$resourceId\"], \"AutomationAssumeRole\": [\"arn:aws:iam::0123456789012:role/TA-ControlPlane-Test-AutomationRole\"]}"
                  },
                  "automationStatus": {
                      "BOOL": true
                  }
              }

              :param check_name: Name of the Trusted Advisor check
              :return: Mapping item from the DDB table, or None if not found
              """
              try:
                  dynamodb = boto3.resource("dynamodb")
                  automation_mapping_table = dynamodb.Table(AUTOMATION_MAPPING_DDB_TABLE_NAME)
                  get_item_response = automation_mapping_table.get_item(
                      Key={"checkName": check_name}
                  )
                  mapping_item = (
                      get_item_response["Item"] if "Item" in get_item_response else None
                  )

              except ClientError as e:
                  logger.warning(
                      f"Error retrieving mapping item from DDB AutomationMappingTable for check {check_name}: {e}"
                  )
                  return None

              return mapping_item


          def _build_execution_automation_parameters(mapping_item, resource_arn):
              """
              Based on the mapping item from the AutomationMappingTable DDB table and resource ARN, construct the automation parameters needed for the SSM automation execution.

              :param mapping_item: Mapping item from the DDB table
              :param resource_arn: ARN of the resource
              :return: Automation parameters in the required format
              """
              regex_pattern = mapping_item.get("regexPattern", "")
              match = re.search(regex_pattern, resource_arn)
              resource_id = match.group()

              if len(resource_id) > 0:
                  automation_parameters = _replace_resource_id(
                      json.loads(mapping_item["automationParameters"]), resource_id
                  )
              else:
                  raise Exception(
                      f"Regex pattern [{regex_pattern}] is not properly defined in ddb mapping table for check [{mapping_item['checkName']}]"
                  )

              return automation_parameters


          def _get_resource_tags(resource_arn, resource_region):
              """
              Get list of tags associated with the resource

              :param resource_arn: ARN of the resource
              :param resource_region: Region of the resource
              :return: List of resource tags. Example: [{'Key': 'automaticRemediation', 'Value': 'True'}]
              """
              try:
                  tag_client = boto3.client(
                      "resourcegroupstaggingapi", region_name=resource_region
                  )
                  resources_paginator = tag_client.get_paginator("get_resources")
                  resource_tag_mapping_lists = resources_paginator.paginate(
                      ResourceARNList=[resource_arn]
                  ).build_full_result()["ResourceTagMappingList"]
              except ClientError as e:
                  logger.warning(
                      f"Failed to retrieve resource tags for resource {resource_arn}. {e}"
                  )
                  return []

              if len(resource_tag_mapping_lists) == 0:
                  return []
              else:
                  # Example return: [{'Key': 'automaticRemediation', 'Value': 'True'}]
                  return resource_tag_mapping_lists[0]["Tags"]


          def _is_resource_level_automatic_remediation_enabled(resource_tags):
              """
              Verifies if the resource level automation remediation is enabled based on the resource tags.

              :param resource_tags: List of resource tags.
              :return: 'True', if the tag key 'automaticRemediation' is present and its value is 'True'. 'False', if the tag is not present or set to 'False'
              """
              automatic_remediation = next(
                  (item for item in resource_tags if item["Key"] == "automaticRemediation"), None
              )
              if automatic_remediation and automatic_remediation["Value"] == "True":
                  return True
              else:
                  logger.info(f"Resource level automation remediation is not enabled.")
                  return False


          def lambda_handler(event, context):
              for record in event["Records"]:
                  """
                  Extracting values from DDB TrustedAdvisorCheckTrackerTable stream. Example event:

                  {'Records': [{'eventID': 'example123id', 'eventName': 'MODIFY', 'eventVersion': '1.1', 'eventSource': 'aws:dynamodb', 'awsRegion': 'us-east-1', 'dynamodb': {'ApproximateCreationDateTime': 1715587134.0, 'Keys': {'hashKey': {'S': 'abc123xyz'}, 'resource': {'S': 'arn:aws:ec2:ap-southeast-2:012345678901:security-group/sg-example123'}}, 'NewImage': {'lastUpdatedTimeEpoch': {'N': '1715573312'}, 'hashKey': {'S': 'abc123xyz'}, 'resourceStatus': {'S': 'Red'}, 'resource': {'S': 'arn:aws:ec2:ap-southeast-2:012345678901:security-group/sg-example123'}, 'lastUpdatedTime': {'S': '2024-05-13T04:08:32.687Z'}, 'checkName': {'S': 'Security groups should not allow unrestricted access to ports with high risk'}, 'region': {'S': 'ap-southeast-2'}}, 'SequenceNumber': '10053100000000041555340248', 'SizeBytes': 498, 'StreamViewType': 'NEW_IMAGE'}, 'eventSourceARN': 'arn:aws:dynamodb:us-east-1:012345678901:table/TrustedAdvisorCheckTrackerTable/stream/2024-05-11T07:16:57.900'}]}
                  """
                  new_image = record["dynamodb"]["NewImage"]
                  check_name = new_image.get("checkName", {}).get("S")
                  resource_arn = new_image.get("resource", {}).get("S")
                  region = new_image.get("region", {}).get("S")
                  hash_key = new_image.get("hashKey", {}).get("S")

                  # Avoid duplicate OpsItem creation.
                  dedup_value = {"dedupString": hash_key}

                  resource_tags = _get_resource_tags(resource_arn, region)

                  mapping_item = _get_ddb_mapping_item(check_name)

                  # Verifies if automation is enabled at resource tag level
                  resource_level_remediation_flag = (
                      _is_resource_level_automatic_remediation_enabled(resource_tags)
                  )

                  # Verifies if automation is enabled at global level in the DDB AutomationMappingTable
                  # 'False' if either 'mapping_item' is None, or, if mapping_item.automationStatus is 'false'
                  global_level_remediation_flag = (
                      mapping_item.get("automationStatus", False) if mapping_item else False
                  )

                  # If automation mapping is not found in AutomationMappingTable DDB table, or, automation is not enabled at resource tag level,
                  # create the OpsItem without any automation execution
                  if not global_level_remediation_flag or not resource_level_remediation_flag:
                      if GEN_AI_RECOMMENDATIONS_ENABLED:
                          invoke_model_url = f"https://{os.environ['AWS_REGION']}.console.aws.amazon.com/systems-manager/automation/execute/taResponderAutomationDocumentInvokeModel?region={os.environ['AWS_REGION']}#AutomationAssumeRole={AUTOMATION_DOCUMENT_INVOKE_MODEL_ROLE}&CheckName={check_name}&AffectedResourceArn={resource_arn}"
                          operational_data = {
                              "flaggedResource": {
                                  "Value": resource_arn,
                                  "Type": "SearchableString",
                              },
                              "/aws/automations": {
                                  "Type": "SearchableString",
                                  "Value": f'[{{"automationType": "AWS::SSM::Automation", "automationId": "{AUTOMATION_DOCUMENT_INVOKE_MODEL}"}}]',
                              },
                              "invokeModelParameters": {
                                  "Type": "String",
                                  "Value": json.dumps(
                                      {
                                          "AutomationAssumeRole": AUTOMATION_DOCUMENT_INVOKE_MODEL_ROLE,
                                          "AffectedResourceArn": resource_arn,
                                          "CheckName": check_name,
                                      }
                                  ),
                              },
                              "invokeModelUrl": {"Value": invoke_model_url, "Type": "String"},
                              "/aws/dedup": {
                                  "Value": json.dumps(dedup_value),
                                  "Type": "SearchableString",
                              },
                          }
                      else:
                          operational_data = {
                              "flaggedResource": {
                                  "Value": resource_arn,
                                  "Type": "SearchableString",
                              },
                              "/aws/dedup": {
                                  "Value": json.dumps(dedup_value),
                                  "Type": "SearchableString",
                              },
                          }

                      # Create the OpsItem
                      ops_item_id = _create_ops_item(check_name, resource_arn, operational_data)
                      return

                  # Create the OpsItem and start the automation execution only if
                  # the automation is enabled at resource tag level and global (AutomationMappingTable DDB table) level
                  elif global_level_remediation_flag and resource_level_remediation_flag:
                      if GEN_AI_RECOMMENDATIONS_ENABLED:
                          invoke_model_url = f"https://{os.environ['AWS_REGION']}.console.aws.amazon.com/systems-manager/automation/execute/taResponderAutomationDocumentInvokeModel?region={os.environ['AWS_REGION']}#AutomationAssumeRole={AUTOMATION_DOCUMENT_INVOKE_MODEL_ROLE}&CheckName={check_name}&AffectedResourceArn={resource_arn}"
                          operational_data = {
                              "flaggedResource": {
                                  "Value": resource_arn,
                                  "Type": "SearchableString",
                              },
                              "/aws/automations": {
                                  "Type": "SearchableString",
                                  "Value": f"[{{\"automationType\": \"AWS::SSM::Automation\", \"automationId\": \"{mapping_item['ssmAutomationDocument']}\"}}, {{\"automationType\": \"AWS::SSM::Automation\", \"automationId\": \"{AUTOMATION_DOCUMENT_INVOKE_MODEL}\"}}]",
                              },
                              "automationParameters": {
                                  "Type": "String",
                                  "Value": json.dumps(mapping_item["automationParameters"]),
                              },
                              "invokeModelParameters": {
                                  "Type": "String",
                                  "Value": json.dumps(
                                      {
                                          "AutomationAssumeRole": AUTOMATION_DOCUMENT_INVOKE_MODEL_ROLE,
                                          "AffectedResourceArn": resource_arn,
                                          "CheckName": check_name,
                                      }
                                  ),
                              },
                              "invokeModelUrl": {"Value": invoke_model_url, "Type": "String"},
                              "/aws/dedup": {
                                  "Value": json.dumps(dedup_value),
                                  "Type": "SearchableString",
                              },
                          }
                      else:
                          operational_data = {
                              "flaggedResource": {
                                  "Value": resource_arn,
                                  "Type": "SearchableString",
                              },
                              "/aws/automations": {
                                  "Type": "SearchableString",
                                  "Value": f"[{{\"automationType\": \"AWS::SSM::Automation\", \"automationId\": \"{mapping_item['ssmAutomationDocument']}\"}}]",
                              },
                              "automationParameters": {
                                  "Type": "String",
                                  "Value": json.dumps(mapping_item["automationParameters"]),
                              },
                              "/aws/dedup": {
                                  "Value": json.dumps(dedup_value),
                                  "Type": "SearchableString",
                              },
                          }

                      automation_parameters = _build_execution_automation_parameters(
                          mapping_item, resource_arn
                      )

                      operational_data["automationParameters"]["Value"] = json.dumps(
                          automation_parameters
                      )

                      # Start automation execution
                      automation_execution_id = _start_automation_execution(
                          mapping_item["ssmAutomationDocument"], automation_parameters, region
                      )

                      # Create the OpsItem
                      ops_item_id = _create_ops_item(check_name, resource_arn, operational_data)

                      # Create item in AutomationExecutionTrackerTable DDB table with OpsItem and Execution Ids
                      if automation_execution_id and ops_item_id:
                          _put_item_in_automation_execution_ddb(
                              automation_execution_id, ops_item_id, region
                          )

              return

  # Lambda source mapping configuration for ingesting events from the DDB TrustedAdvisorCheckTrackerTable event stream
  LambdaEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt TrustedAdvisorCheckTrackerTable.StreamArn
      FunctionName: !Ref TrustedAdvisorResultHandlerFunction
      StartingPosition: LATEST
      BatchSize: 1
      FilterCriteria:
        Filters:
          - Pattern: '{ "dynamodb": { "NewImage": { "resourceStatus": { "S": ["Red", "Yellow"] } } } }'

  TrustedAdvisorResultHandlerExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                Resource:
                  - !GetAtt AutomationMappingTable.Arn
                  - !GetAtt AutomationExecutionTrackerTable.Arn
              - Effect: Allow
                Action:
                  - dynamodb:DescribeStream
                  - dynamodb:GetRecords
                  - dynamodb:GetShardIterator
                  - dynamodb:ListStreams
                Resource: !GetAtt TrustedAdvisorCheckTrackerTable.StreamArn
        - PolicyName: CreateOpsItemPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:CreateOpsItem'
                Resource: '*'
        - PolicyName: SSMAutomationExecution
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:StartAutomationExecution'
                Resource: '*'
        - PolicyName: GetResourcesTag
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'tag:GetResources'
                Resource: '*'
        - PolicyName: IAMPassRole
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'iam:PassRole'
                Resource: '*'

  # Example Automation Role use for the TA Check <> SSM Automation Document mapping configuration
  # This example gives permission to actions needed by the AWS-DisablePublicAccessForSecurityGroup automation document
  AutomationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub 'arn:aws:ssm:*:${AWS::AccountId}:automation-execution/*'
      Policies:
        - PolicyName: AutomationRolePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:RevokeSecurityGroupIngress
                Resource: '*'

  # Lambda function for handling events sourced from the EventBridge rule related to SSM Automation Execution completions
  SSMAutomationExecutionEventsHandler:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: SSMAutomationExecutionEventsHandler
      Runtime: python3.12
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import boto3
          import logging

          logging.getLogger().setLevel(logging.INFO)
          logger = logging.getLogger()

          dynamodb_client = boto3.resource('dynamodb')
          ssm_client = boto3.client('ssm')

          table_name = 'AutomationExecutionTrackerTable'

          def lambda_handler(event, context):
              # Get the detail from the event
              detail = event['detail']
              execution_id = detail['ExecutionId']
              automation_execution_document_name = detail['Definition']
              automation_execution_status = detail['Status']

              # Get the item from the DynamoDB table
              table = dynamodb_client.Table(table_name)
              response = table.get_item(Key={'automationExecutionId': execution_id})
              item = response.get('Item')

              if item:
                  ops_item_id = item['opsItemId']
                  region = item['region']

                  if automation_execution_status == 'Success':
                      # Update the OpsItem with Resolved status
                      ssm_client.update_ops_item(
                          OpsItemId=ops_item_id,
                          Status='Resolved',
                          OperationalData={
                              "trustedAdvisorCheckAutoRemediation": {
                                  "Type": "String",
                                  "Value": f"DocumentName: {automation_execution_document_name}, ExecutionId: {execution_id}, Status: {automation_execution_status}, Region: {region}"
                              }
                          }
                      )
                  else:
                      # Update the OpsItem with the execution status
                      ssm_client.update_ops_item(
                          OpsItemId=ops_item_id,
                          OperationalData={
                              "trustedAdvisorCheckAutoRemediation": {
                                  "Type": "String",
                                  "Value": f"DocumentName: {automation_execution_document_name}, ExecutionId: {execution_id}, Status: {automation_execution_status}, Region: {region}"
                              }
                          }
                      )
                  # Delete the item from the DynamoDB table
                  table.delete_item(
                      Key={
                          'automationExecutionId': execution_id
                      }
                  )
                  logger.info(f"Deleted item with automationExecutionId {execution_id} from DynamoDB table")

              return
      Handler: index.lambda_handler
      Role: !GetAtt SSMAutomationExecutionEventsLambdaRole.Arn

  SSMAutomationExecutionEventsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:DeleteItem
                Resource:
                  - !GetAtt AutomationExecutionTrackerTable.Arn
        - PolicyName: UpdateOpsItemPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:UpdateOpsItem'
                Resource: '*'

  # EventBridge rule matching events related to SSM Automation Execution completions
  SSMAutomationExecutionEventsRule:
    Type: AWS::Events::Rule
    Properties:
      Name: SSMAutomationExecutionEventsRule
      EventPattern:
        source:
          - aws.ssm
        detail-type:
          - 'EC2 Automation Execution Status-change Notification'
        detail:
          Status:
            - Success
            - TimedOut
            - Cancelled
            - Failed
            - Rejected
            - Exited
      State: ENABLED
      Targets:
        - Arn: !GetAtt SSMAutomationExecutionEventsHandler.Arn
          Id: SSMAutomationExecutionEventsHandler

  PermissionForEventsToInvokeLambda:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SSMAutomationExecutionEventsHandler
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      SourceArn: !GetAtt SSMAutomationExecutionEventsRule.Arn

  # SSM Automation Document for invoking the model and retrieve further recommendations regarding the TA finding
  TaResponderAutomationDocumentInvokeModel:
    Type: AWS::SSM::Document
    Condition: CreateGenAIResources
    Properties:
      DocumentType: Automation
      Name: taResponderAutomationDocumentInvokeModel
      UpdateMethod: NewVersion
      Content:
        schemaVersion: '0.3'
        description: 'Generate AI recommendations for Trusted Advisor findings using Bedrock'
        assumeRole: '{{ AutomationAssumeRole }}'
        parameters:
          AutomationAssumeRole:
            type: String
            description: '(Required) The Amazon Resource Name (ARN) of the IAM role that allows Automation to perform the actions on your behalf.'
          AffectedResourceArn:
            type: String
            description: '(Required) ARN of the resource'
          CheckName:
            type: String
            description: '(Required) Name of the Trusted Advisor check'
          ModelId:
            type: String
            description: '(Required) Bedrock Model ID'
            default: !Ref GenAIModelId
        mainSteps:
          - name: InvokeBedrockAndExtractAnswer
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.11
              Handler: handler
              InputPayload:
                affectedResourceArn: '{{AffectedResourceArn}}'
                checkName: '{{CheckName}}'
                modelId: '{{ModelId}}'
              Script: |-
                """This is the main Python script used by the 'TaResponderAutomationDocumentInvokeModel' SSM Automation document to get recommendations for TA check findings"""

                import json

                import boto3


                def get_trusted_advisor_check(check_name):
                    # boto3 client for Trusted Advisor
                    client = boto3.client("trustedadvisor")

                    paginator = client.get_paginator("list_checks")

                    # Initialize an empty list to store all check summaries
                    all_check_summaries = []

                    # Paginate through all results
                    for page in paginator.paginate():
                        all_check_summaries.extend(page["checkSummaries"])

                    # Find the check summary that matches the provided name
                    matching_check = next(
                        (check for check in all_check_summaries if check["name"] == check_name), None
                    )

                    return matching_check


                def array_to_string(arr):
                    if len(arr) == 0:
                        return ""
                    elif len(arr) == 1:
                        return arr[0]
                    elif len(arr) == 2:
                        return f"{arr[0]} and {arr[1]}"
                    else:
                        return ", ".join(arr[:-1]) + f", and {arr[-1]}"


                def invoke_bedrock_and_extract(
                    affected_resource_arn, check_name, model_id, check_details
                ):
                    bedrock_runtime = boto3.client("bedrock-runtime")

                    related_aws_services = array_to_string(check_details.get("awsServices", []))

                    related_pillars = array_to_string(check_details.get("pillars", []))

                    check_description = check_details.get("description", [])

                    system_prompt = f"""You are an AWS Cloud Solutions Architect who specializes in the AWS Well-Architected Framework, and in running a process called the Well-Architected Framework Review (WAFR). The WAFR process consists of evaluating a cloud workload against the 6 pillars of the Well-Architected Framework, namely - Operational Excellence Pillar, Security Pillar, Reliability Pillar, Performance Efficiency Pillar, Cost Optimization Pillar, and Sustainability Pillar - all of this in order to establish good architectural habits, manage and eliminate risk and increase the adoption of best practices.
                    
                    You are also a subject matter expert in the {related_aws_services} AWS services, and have experience in troubleshooting and resolving complex technical problems on these services. You are able to review findings from AWS Trusted Advisor checks, and suggest possible root cause and solutions for the issues found.
                    
                    Follow the instructions listed under "instructions" section below.

                    <instructions>
                    1) In the <check_name> section, you are provided with the name of a specific Trusted Advisor Check related to the {related_pillars} pillar(s), which has found a resource to be not compliance with its evaluation (e.g. the resource was flagged as either Red or Yellow by the check evaluation).
                    2) In the <check_description> section, you are provided with more details about this Trusted Advisor Check. This <check_description> section contains a description about what this check is evaluating, it details the "Alert Criteria" used by this check to evaluate whether a resource is flagged as either Red/Yellow/Green, and it also provides with "Recommended Action" information and "Additional Resources" with useful links.
                    3) In the <affected_resource_arn> section, you are provided with the ARN or unique identifier of the resource that was flagged by the Trusted Advisor Check. This is the resource that needs to be remediated.
                    4) In alignment with the Trusted Advisor Check and related AWS Well-Architected Framework best practices, provide recommendations on how to fix the issue identified by the Trusted Advisor Check.
                    5) When possible, provide with step by step instruction on how to fix the issue. Also, when applicable, include AWS CLI commands that can be used to fix the issue (this should be tailored to the specific resource identified in the <affected_resource_arn> section).
                    6) Finally, make sure to include a disclaimer at the beginning of your response, stating that it was generated by a Gen AI model.
                    </instructions>
                    """

                    prompt = f"""
                    <check_name>
                    {check_name}
                    </check_name>

                    <check_description>
                    {check_description}
                    </check_description>

                    <affected_resource_arn>
                    {affected_resource_arn}
                    </affected_resource_arn>
                    """

                    body = json.dumps(
                        {
                            "anthropic_version": "bedrock-2023-05-31",
                            "max_tokens": 2000,
                            "temperature": 0.5,
                            "system": system_prompt,
                            "messages": [
                                {"role": "user", "content": [{"type": "text", "text": prompt}]}
                            ],
                        }
                    )

                    response = bedrock_runtime.invoke_model(
                        body=body,
                        modelId=model_id,
                        accept="application/json",
                        contentType="application/json",
                    )

                    response_body = json.loads(response["body"].read())
                    answer = response_body["content"][0]["text"]

                    return {"Answer": answer}


                def handler(events, context):
                    affected_resource_arn = events["affectedResourceArn"]
                    check_name = events["checkName"]
                    model_id = events["modelId"]

                    # Get the Trusted Advisor check details
                    check_details = get_trusted_advisor_check(check_name)

                    # Invoke the Bedrock model and get the response
                    model_response = invoke_bedrock_and_extract(
                        affected_resource_arn, check_name, model_id, check_details
                    )

                    # Return the model response
                    return model_response
            outputs:
              - Name: AIRecommendation
                Selector: '$.Payload.Answer'
                Type: String
        outputs:
          - 'InvokeBedrockAndExtractAnswer.AIRecommendation'

  # IAM Role for the InvokeModel SSM Automation Document
  TaResponderAutomationExecutionRoleInvokeModel:
    Type: AWS::IAM::Role
    Condition: CreateGenAIResources
    Properties:
      RoleName: taResponderAutomationDocumentInvokeModelRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: BedrockInvokeModelPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource: 'arn:aws:bedrock:*::foundation-model/*'
        - PolicyName: listTaChecks
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - trustedadvisor:ListChecks
                Resource: '*'

Outputs:

  AutomationRoleArn:
    Description: The ARN of IAM Role to be used by the Automation Documents
    Value: !GetAtt AutomationRole.Arn
    Export:
      Name: AutomationRoleArn